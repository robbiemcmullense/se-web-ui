/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { Components, JSX } from '@se/web-ui';


interface SeFormFieldProps {
  
  /** Defines the layout of your form field.
`inline` is the default option, and is always applied if the type is set to `checkbox`.  This sets the input or select field adjacent to the label.
`stacked` option will render the input or select field below the label. */
  option?: Components.SeFormField["option"]
  
  /** Defines the layout of your form field. If `true`, the input field will render bellow the label. */
  stacked?: Components.SeFormField["stacked"]
  
  /** Defines the spacing around the inside edge of a container.
`none` is 0px.
`small` is 4px.
`medium` is 8px. */
  padding?: Components.SeFormField["padding"]
  
  /** Optional property that defines if the field displays as a block in it's container.
When set to true, the field will be as wide as its container.
both field label auto adjust when it set to inline */
  block?: Components.SeFormField["block"]
  
  /** Optional property to define the proportion of the label width. The content (input) will take the rest of if. Defaulted to 40% */
  labelWidth?: Components.SeFormField["labelWidth"]
  
  /** Optional property to define how to align the label */
  labelAlign?: Components.SeFormField["labelAlign"]
  
  /** Defines whether the form field's input is a text field (`input`), a checkbox (`checkbox`), a radio button (`radio`), or a dropdown menu (`select`).
`input` is the default type. */
  type?: Components.SeFormField["type"]
  
  /** Sets a red border on an input field if there's an error, an orange border if there's a warning, and a green border if a successful input. */
  status?: Components.SeFormField["status"]
  
  /** Defines the text value of the label in your form field. */
  label?: Components.SeFormField["label"]
  
  /** Defines if the field is a text, to add a padding and better align with other fields. */
  textOnly?: Components.SeFormField["textOnly"]
  
  /** Defines the value of your form field to get passed to the parent component.
When the type is set to "input", this value will be the default placeholder in your input field. */
  value?: Components.SeFormField["value"]
  
  /** Determines if the input is required by the application.
Set to `false` by default.
Setting this value to `true` will render a red asterisk next to your label. */
  required?: Components.SeFormField["required"]
  
  /** Optional property that defines if the form field is disabled.  Set to `false` by default. */
  disabled?: Components.SeFormField["disabled"]
  
  /** Optional property that defines if the form-filed should not stack even if the container is small (it won't be responsive). */
  noStacking?: Components.SeFormField["noStacking"]
  
  /** Optional property that defines the minumum width after witch the form field will move to stacked mode. */
  minWidth?: Components.SeFormField["minWidth"]
}

interface SeFormFieldEvents {
  
  /** Passes form data to the parent component on a click (`checkbox` or `radio`), menu change (`select`), or when the input field loses focus. */
  didSubmit: Parameters<JSX.SeFormField["onDidSubmit"]>[0]
}

interface SeFormFieldSlots {
  default: any
}
  
/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	binding_callbacks,
	create_slot,
	detach,
	element,
	flush,
	init,
	insert,
	listen,
	safe_not_equal,
	set_custom_element_data,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { createEventDispatcher, onMount } from "svelte";

function create_fragment(ctx) {
	let se_form_field;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			se_form_field = element("se-form-field");
			if (default_slot) default_slot.c();
			set_custom_element_data(se_form_field, "option", /*option*/ ctx[0]);
			set_custom_element_data(se_form_field, "stacked", /*stacked*/ ctx[1]);
			set_custom_element_data(se_form_field, "padding", /*padding*/ ctx[2]);
			set_custom_element_data(se_form_field, "block", /*block*/ ctx[3]);
			set_custom_element_data(se_form_field, "label-width", /*labelWidth*/ ctx[4]);
			set_custom_element_data(se_form_field, "label-align", /*labelAlign*/ ctx[5]);
			set_custom_element_data(se_form_field, "type", /*type*/ ctx[6]);
			set_custom_element_data(se_form_field, "status", /*status*/ ctx[7]);
			set_custom_element_data(se_form_field, "label", /*label*/ ctx[8]);
			set_custom_element_data(se_form_field, "text-only", /*textOnly*/ ctx[9]);
			set_custom_element_data(se_form_field, "value", /*value*/ ctx[10]);
			set_custom_element_data(se_form_field, "required", /*required*/ ctx[11]);
			set_custom_element_data(se_form_field, "disabled", /*disabled*/ ctx[12]);
			set_custom_element_data(se_form_field, "no-stacking", /*noStacking*/ ctx[13]);
			set_custom_element_data(se_form_field, "min-width", /*minWidth*/ ctx[14]);
		},
		m(target, anchor) {
			insert(target, se_form_field, anchor);

			if (default_slot) {
				default_slot.m(se_form_field, null);
			}

			/*se_form_field_binding*/ ctx[20](se_form_field);
			current = true;

			if (!mounted) {
				dispose = listen(se_form_field, "didSubmit", /*onEvent*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], !current ? -1 : dirty, null, null);
				}
			}

			if (!current || dirty & /*option*/ 1) {
				set_custom_element_data(se_form_field, "option", /*option*/ ctx[0]);
			}

			if (!current || dirty & /*stacked*/ 2) {
				set_custom_element_data(se_form_field, "stacked", /*stacked*/ ctx[1]);
			}

			if (!current || dirty & /*padding*/ 4) {
				set_custom_element_data(se_form_field, "padding", /*padding*/ ctx[2]);
			}

			if (!current || dirty & /*block*/ 8) {
				set_custom_element_data(se_form_field, "block", /*block*/ ctx[3]);
			}

			if (!current || dirty & /*labelWidth*/ 16) {
				set_custom_element_data(se_form_field, "label-width", /*labelWidth*/ ctx[4]);
			}

			if (!current || dirty & /*labelAlign*/ 32) {
				set_custom_element_data(se_form_field, "label-align", /*labelAlign*/ ctx[5]);
			}

			if (!current || dirty & /*type*/ 64) {
				set_custom_element_data(se_form_field, "type", /*type*/ ctx[6]);
			}

			if (!current || dirty & /*status*/ 128) {
				set_custom_element_data(se_form_field, "status", /*status*/ ctx[7]);
			}

			if (!current || dirty & /*label*/ 256) {
				set_custom_element_data(se_form_field, "label", /*label*/ ctx[8]);
			}

			if (!current || dirty & /*textOnly*/ 512) {
				set_custom_element_data(se_form_field, "text-only", /*textOnly*/ ctx[9]);
			}

			if (!current || dirty & /*value*/ 1024) {
				set_custom_element_data(se_form_field, "value", /*value*/ ctx[10]);
			}

			if (!current || dirty & /*required*/ 2048) {
				set_custom_element_data(se_form_field, "required", /*required*/ ctx[11]);
			}

			if (!current || dirty & /*disabled*/ 4096) {
				set_custom_element_data(se_form_field, "disabled", /*disabled*/ ctx[12]);
			}

			if (!current || dirty & /*noStacking*/ 8192) {
				set_custom_element_data(se_form_field, "no-stacking", /*noStacking*/ ctx[13]);
			}

			if (!current || dirty & /*minWidth*/ 16384) {
				set_custom_element_data(se_form_field, "min-width", /*minWidth*/ ctx[14]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(se_form_field);
			if (default_slot) default_slot.d(detaching);
			/*se_form_field_binding*/ ctx[20](null);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let __ref;
	let __mounted = false;
	const dispatch = createEventDispatcher();
	let { option = undefined } = $$props;
	let { stacked = undefined } = $$props;
	let { padding = undefined } = $$props;
	let { block = undefined } = $$props;
	let { labelWidth = undefined } = $$props;
	let { labelAlign = undefined } = $$props;
	let { type = undefined } = $$props;
	let { status = undefined } = $$props;
	let { label = undefined } = $$props;
	let { textOnly = undefined } = $$props;
	let { value = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { noStacking = undefined } = $$props;
	let { minWidth = undefined } = $$props;
	const getWebComponent = () => __ref;

	onMount(() => {
		__mounted = true;
	});

	const setProp = (prop, value) => {
		if (__ref) $$invalidate(15, __ref[prop] = value, __ref);
	};

	const onEvent = e => {
		e.stopPropagation();
		dispatch(e.type, e.detail);
	};

	function se_form_field_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			__ref = $$value;
			$$invalidate(15, __ref);
		});
	}

	$$self.$$set = $$props => {
		if ("option" in $$props) $$invalidate(0, option = $$props.option);
		if ("stacked" in $$props) $$invalidate(1, stacked = $$props.stacked);
		if ("padding" in $$props) $$invalidate(2, padding = $$props.padding);
		if ("block" in $$props) $$invalidate(3, block = $$props.block);
		if ("labelWidth" in $$props) $$invalidate(4, labelWidth = $$props.labelWidth);
		if ("labelAlign" in $$props) $$invalidate(5, labelAlign = $$props.labelAlign);
		if ("type" in $$props) $$invalidate(6, type = $$props.type);
		if ("status" in $$props) $$invalidate(7, status = $$props.status);
		if ("label" in $$props) $$invalidate(8, label = $$props.label);
		if ("textOnly" in $$props) $$invalidate(9, textOnly = $$props.textOnly);
		if ("value" in $$props) $$invalidate(10, value = $$props.value);
		if ("required" in $$props) $$invalidate(11, required = $$props.required);
		if ("disabled" in $$props) $$invalidate(12, disabled = $$props.disabled);
		if ("noStacking" in $$props) $$invalidate(13, noStacking = $$props.noStacking);
		if ("minWidth" in $$props) $$invalidate(14, minWidth = $$props.minWidth);
		if ("$$scope" in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	};

	return [
		option,
		stacked,
		padding,
		block,
		labelWidth,
		labelAlign,
		type,
		status,
		label,
		textOnly,
		value,
		required,
		disabled,
		noStacking,
		minWidth,
		__ref,
		onEvent,
		getWebComponent,
		$$scope,
		slots,
		se_form_field_binding
	];
}

class SeFormField extends SvelteComponent {
  $$prop_def: SeFormFieldProps;
  $$events_def: SeFormFieldEvents;
  $$slot_def: SeFormFieldSlots;

  $on<K extends keyof SeFormFieldEvents>(type: K, callback: (e: SeFormFieldEvents[K]) => any): () => void {
	  return super.$on(type, callback);
	}

  $set($$props: Partial<SeFormFieldProps>): void {
	  super.$set($$props);
	}

	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			option: 0,
			stacked: 1,
			padding: 2,
			block: 3,
			labelWidth: 4,
			labelAlign: 5,
			type: 6,
			status: 7,
			label: 8,
			textOnly: 9,
			value: 10,
			required: 11,
			disabled: 12,
			noStacking: 13,
			minWidth: 14,
			getWebComponent: 17
		});
	}

	get option() {
		return this.$$.ctx[0];
	}

	set option(option) {
		this.$set({ option });
		flush();
	}

	get stacked() {
		return this.$$.ctx[1];
	}

	set stacked(stacked) {
		this.$set({ stacked });
		flush();
	}

	get padding() {
		return this.$$.ctx[2];
	}

	set padding(padding) {
		this.$set({ padding });
		flush();
	}

	get block() {
		return this.$$.ctx[3];
	}

	set block(block) {
		this.$set({ block });
		flush();
	}

	get labelWidth() {
		return this.$$.ctx[4];
	}

	set labelWidth(labelWidth) {
		this.$set({ labelWidth });
		flush();
	}

	get labelAlign() {
		return this.$$.ctx[5];
	}

	set labelAlign(labelAlign) {
		this.$set({ labelAlign });
		flush();
	}

	get type() {
		return this.$$.ctx[6];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get status() {
		return this.$$.ctx[7];
	}

	set status(status) {
		this.$set({ status });
		flush();
	}

	get label() {
		return this.$$.ctx[8];
	}

	set label(label) {
		this.$set({ label });
		flush();
	}

	get textOnly() {
		return this.$$.ctx[9];
	}

	set textOnly(textOnly) {
		this.$set({ textOnly });
		flush();
	}

	get value() {
		return this.$$.ctx[10];
	}

	set value(value) {
		this.$set({ value });
		flush();
	}

	get required() {
		return this.$$.ctx[11];
	}

	set required(required) {
		this.$set({ required });
		flush();
	}

	get disabled() {
		return this.$$.ctx[12];
	}

	set disabled(disabled) {
		this.$set({ disabled });
		flush();
	}

	get noStacking() {
		return this.$$.ctx[13];
	}

	set noStacking(noStacking) {
		this.$set({ noStacking });
		flush();
	}

	get minWidth() {
		return this.$$.ctx[14];
	}

	set minWidth(minWidth) {
		this.$set({ minWidth });
		flush();
	}

	get getWebComponent(): HTMLSeFormFieldElement | undefined {
		return this.$$.ctx[17];
	}
}

export default SeFormField;